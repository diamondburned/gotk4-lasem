// Code generated by girgen. DO NOT EDIT.

package lasem

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <lsm.h>
// #include <lsmdom.h>
// #include <lsmdomdocument.h>
// #include <lsmdomdocumentfragment.h>
// #include <lsmdomnamednodemap.h>
import "C"

// glib.Type values for lsmattributes.go.
var GTypeAttributeManager = externglib.Type(C.lsm_attribute_manager_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeAttributeManager, F: marshalAttributeManager},
	})
}

// Attribute: instance of this type is always passed by reference.
type Attribute struct {
	*attribute
}

// attribute is the struct that's finalized.
type attribute struct {
	native *C.LsmAttribute
}

func (a *Attribute) Value() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(a.native.value)))
	return v
}

// The function returns the following values:
//
func (attribute *Attribute) IsDefined() bool {
	var _arg0 *C.LsmAttribute // out
	var _cret C.gboolean      // in

	_arg0 = (*C.LsmAttribute)(gextras.StructNative(unsafe.Pointer(attribute)))

	_cret = C.lsm_attribute_is_defined(_arg0)
	runtime.KeepAlive(attribute)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AttributeInfos: instance of this type is always passed by reference.
type AttributeInfos struct {
	*attributeInfos
}

// attributeInfos is the struct that's finalized.
type attributeInfos struct {
	native *C.LsmAttributeInfos
}

// AttributeManager: instance of this type is always passed by reference.
type AttributeManager struct {
	*attributeManager
}

// attributeManager is the struct that's finalized.
type attributeManager struct {
	native *C.LsmAttributeManager
}

func marshalAttributeManager(p uintptr) (interface{}, error) {
	b := externglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &AttributeManager{&attributeManager{(*C.LsmAttributeManager)(b)}}, nil
}

// NewAttributeManager constructs a struct AttributeManager.
func NewAttributeManager(nAttributes uint, attributeInfos *AttributeInfos) *AttributeManager {
	var _arg1 C.uint                 // out
	var _arg2 *C.LsmAttributeInfos   // out
	var _cret *C.LsmAttributeManager // in

	_arg1 = C.uint(nAttributes)
	_arg2 = (*C.LsmAttributeInfos)(gextras.StructNative(unsafe.Pointer(attributeInfos)))

	_cret = C.lsm_attribute_manager_new(_arg1, _arg2)
	runtime.KeepAlive(nAttributes)
	runtime.KeepAlive(attributeInfos)

	var _attributeManager *AttributeManager // out

	_attributeManager = (*AttributeManager)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attributeManager)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.lsm_attribute_manager_unref((*C.LsmAttributeManager)(intern.C))
		},
	)

	return _attributeManager
}

// The function takes the following parameters:
//
//    - nAttributes
//    - attributeInfos
//
func (manager *AttributeManager) AddAttributes(nAttributes uint, attributeInfos *AttributeInfos) {
	var _arg0 *C.LsmAttributeManager // out
	var _arg1 C.uint                 // out
	var _arg2 *C.LsmAttributeInfos   // out

	_arg0 = (*C.LsmAttributeManager)(gextras.StructNative(unsafe.Pointer(manager)))
	_arg1 = C.uint(nAttributes)
	_arg2 = (*C.LsmAttributeInfos)(gextras.StructNative(unsafe.Pointer(attributeInfos)))

	C.lsm_attribute_manager_add_attributes(_arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(nAttributes)
	runtime.KeepAlive(attributeInfos)
}

// The function returns the following values:
//
func (origin *AttributeManager) Duplicate() *AttributeManager {
	var _arg0 *C.LsmAttributeManager // out
	var _cret *C.LsmAttributeManager // in

	_arg0 = (*C.LsmAttributeManager)(gextras.StructNative(unsafe.Pointer(origin)))

	_cret = C.lsm_attribute_manager_duplicate(_arg0)
	runtime.KeepAlive(origin)

	var _attributeManager *AttributeManager // out

	_attributeManager = (*AttributeManager)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attributeManager)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.lsm_attribute_manager_unref((*C.LsmAttributeManager)(intern.C))
		},
	)

	return _attributeManager
}
