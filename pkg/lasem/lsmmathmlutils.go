// Code generated by girgen. DO NOT EDIT.

package lasem

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
)

// #include <stdlib.h>
// #include <lsm.h>
// #include <lsmdom.h>
// #include <lsmdomdocument.h>
// #include <lsmdomdocumentfragment.h>
// #include <lsmdomnamednodemap.h>
// #include <lsmmathmlactionelement.h>
// #include <lsmmathmlaligngroupelement.h>
// #include <lsmmathmlalignmarkelement.h>
// #include <lsmmathmlattributes.h>
// #include <lsmmathmldocument.h>
// #include <lsmmathmlelement.h>
// #include <lsmmathmlencloseelement.h>
// #include <lsmmathmlenums.h>
// #include <lsmmathmlerrorelement.h>
// #include <lsmmathmlfencedelement.h>
// #include <lsmmathmlfractionelement.h>
// #include <lsmmathmlglyphtableams.h>
// #include <lsmmathmlitexelement.h>
// #include <lsmmathmllayoututils.h>
// #include <lsmmathmlmathelement.h>
// #include <lsmmathmloperatordictionary.h>
// #include <lsmmathmloperatorelement.h>
// #include <lsmmathmlpaddedelement.h>
// #include <lsmmathmlphantomelement.h>
// #include <lsmmathmlpresentationcontainer.h>
// #include <lsmmathmlpresentationtoken.h>
// #include <lsmmathmlradicalelement.h>
// #include <lsmmathmlrowelement.h>
// #include <lsmmathmlscriptelement.h>
// #include <lsmmathmlsemanticselement.h>
// #include <lsmmathmlspaceelement.h>
// #include <lsmmathmlstringelement.h>
// #include <lsmmathmlstyle.h>
// #include <lsmmathmlstyleelement.h>
// #include <lsmmathmltablecellelement.h>
// #include <lsmmathmltableelement.h>
// #include <lsmmathmltablerowelement.h>
// #include <lsmmathmltraits.h>
// #include <lsmmathmlunderoverelement.h>
// #include <lsmmathmlutils.h>
// #include <lsmmathmlview.h>
// #include <lsmsvgaelement.h>
// #include <lsmsvgattributes.h>
// #include <lsmsvgcircleelement.h>
// #include <lsmsvgclippathelement.h>
// #include <lsmsvgcolors.h>
// #include <lsmsvgdefselement.h>
// #include <lsmsvgdocument.h>
// #include <lsmsvgelement.h>
// #include <lsmsvgellipseelement.h>
// #include <lsmsvgenums.h>
// #include <lsmsvgfilterblend.h>
// #include <lsmsvgfiltercolormatrix.h>
// #include <lsmsvgfiltercomposite.h>
// #include <lsmsvgfilterconvolvematrix.h>
// #include <lsmsvgfilterdisplacementmap.h>
// #include <lsmsvgfilterelement.h>
// #include <lsmsvgfilterflood.h>
// #include <lsmsvgfiltergaussianblur.h>
// #include <lsmsvgfilterimage.h>
// #include <lsmsvgfiltermerge.h>
// #include <lsmsvgfiltermergenode.h>
// #include <lsmsvgfiltermorphology.h>
// #include <lsmsvgfilteroffset.h>
// #include <lsmsvgfilterprimitive.h>
// #include <lsmsvgfilterspecularlighting.h>
// #include <lsmsvgfiltersurface.h>
// #include <lsmsvgfiltertile.h>
// #include <lsmsvgfilterturbulence.h>
// #include <lsmsvggelement.h>
// #include <lsmsvggradientelement.h>
// #include <lsmsvgimageelement.h>
// #include <lsmsvglength.h>
// #include <lsmsvglineargradientelement.h>
// #include <lsmsvglineelement.h>
// #include <lsmsvgmarkerelement.h>
// #include <lsmsvgmaskelement.h>
// #include <lsmsvgmatrix.h>
// #include <lsmsvgpathelement.h>
// #include <lsmsvgpatternelement.h>
// #include <lsmsvgpolygonelement.h>
// #include <lsmsvgpolylineelement.h>
// #include <lsmsvgradialgradientelement.h>
// #include <lsmsvgrectelement.h>
// #include <lsmsvgstopelement.h>
// #include <lsmsvgstyle.h>
// #include <lsmsvgsvgelement.h>
// #include <lsmsvgswitchelement.h>
// #include <lsmsvgsymbolelement.h>
// #include <lsmsvgtextelement.h>
// #include <lsmsvgtraits.h>
// #include <lsmsvgtransformable.h>
// #include <lsmsvgtspanelement.h>
// #include <lsmsvguseelement.h>
// #include <lsmsvgview.h>
import "C"

// MathMLBbox: instance of this type is always passed by reference.
type MathMLBbox struct {
	*mathMLBbox
}

// mathMLBbox is the struct that's finalized.
type mathMLBbox struct {
	native *C.LsmMathmlBbox
}

// NewMathMLBbox creates a new MathMLBbox instance from the given
// fields.
func NewMathMLBbox(width, height, depth float64, isDefined bool) MathMLBbox {
	var f0 C.double // out
	f0 = C.double(width)
	var f1 C.double // out
	f1 = C.double(height)
	var f2 C.double // out
	f2 = C.double(depth)
	var f3 C.gboolean // out
	if isDefined {
		f3 = C.TRUE
	}

	v := C.LsmMathmlBbox{
		width:      f0,
		height:     f1,
		depth:      f2,
		is_defined: f3,
	}

	return *(*MathMLBbox)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

func (m *MathMLBbox) Width() float64 {
	var v float64 // out
	v = float64(m.native.width)
	return v
}

func (m *MathMLBbox) Height() float64 {
	var v float64 // out
	v = float64(m.native.height)
	return v
}

func (m *MathMLBbox) Depth() float64 {
	var v float64 // out
	v = float64(m.native.depth)
	return v
}

func (m *MathMLBbox) IsDefined() bool {
	var v bool // out
	if m.native.is_defined != 0 {
		v = true
	}
	return v
}

// The function takes the following parameters:
//
func (bbox *MathMLBbox) AddHorizontally(newBbox *MathMLBbox) {
	var _arg0 *C.LsmMathmlBbox // out
	var _arg1 *C.LsmMathmlBbox // out

	_arg0 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))
	_arg1 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(newBbox)))

	C.lsm_mathml_bbox_add_horizontally(_arg0, _arg1)
	runtime.KeepAlive(bbox)
	runtime.KeepAlive(newBbox)
}

// The function takes the following parameters:
//
func (self *MathMLBbox) AddOver(bbox *MathMLBbox) {
	var _arg0 *C.LsmMathmlBbox // out
	var _arg1 *C.LsmMathmlBbox // out

	_arg0 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))

	C.lsm_mathml_bbox_add_over(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bbox)
}

// The function takes the following parameters:
//
func (self *MathMLBbox) AddUnder(bbox *MathMLBbox) {
	var _arg0 *C.LsmMathmlBbox // out
	var _arg1 *C.LsmMathmlBbox // out

	_arg0 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))

	C.lsm_mathml_bbox_add_under(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bbox)
}

// The function takes the following parameters:
//
//    - bbox
//    - offset
//
func (self *MathMLBbox) MergeVertically(bbox *MathMLBbox, offset float64) {
	var _arg0 *C.LsmMathmlBbox // out
	var _arg1 *C.LsmMathmlBbox // out
	var _arg2 C.double         // out

	_arg0 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))
	_arg2 = C.double(offset)

	C.lsm_mathml_bbox_merge_vertically(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bbox)
	runtime.KeepAlive(offset)
}

// The function takes the following parameters:
//
func (self *MathMLBbox) Stretch(bbox *MathMLBbox) {
	var _arg0 *C.LsmMathmlBbox // out
	var _arg1 *C.LsmMathmlBbox // out

	_arg0 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))

	C.lsm_mathml_bbox_stretch(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bbox)
}

// The function takes the following parameters:
//
func (self *MathMLBbox) StretchHorizontally(bbox *MathMLBbox) {
	var _arg0 *C.LsmMathmlBbox // out
	var _arg1 *C.LsmMathmlBbox // out

	_arg0 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))

	C.lsm_mathml_bbox_stretch_horizontally(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bbox)
}

// The function takes the following parameters:
//
func (self *MathMLBbox) StretchVertically(bbox *MathMLBbox) {
	var _arg0 *C.LsmMathmlBbox // out
	var _arg1 *C.LsmMathmlBbox // out

	_arg0 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))

	C.lsm_mathml_bbox_stretch_vertically(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(bbox)
}

// MathMLPadding: instance of this type is always passed by reference.
type MathMLPadding struct {
	*mathMLPadding
}

// mathMLPadding is the struct that's finalized.
type mathMLPadding struct {
	native *C.LsmMathmlPadding
}

// NewMathMLPadding creates a new MathMLPadding instance from the given
// fields.
func NewMathMLPadding(left, right, top, bottom float64) MathMLPadding {
	var f0 C.double // out
	f0 = C.double(left)
	var f1 C.double // out
	f1 = C.double(right)
	var f2 C.double // out
	f2 = C.double(top)
	var f3 C.double // out
	f3 = C.double(bottom)

	v := C.LsmMathmlPadding{
		left:   f0,
		right:  f1,
		top:    f2,
		bottom: f3,
	}

	return *(*MathMLPadding)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

func (m *MathMLPadding) Left() float64 {
	var v float64 // out
	v = float64(m.native.left)
	return v
}

func (m *MathMLPadding) Right() float64 {
	var v float64 // out
	v = float64(m.native.right)
	return v
}

func (m *MathMLPadding) Top() float64 {
	var v float64 // out
	v = float64(m.native.top)
	return v
}

func (m *MathMLPadding) Bottom() float64 {
	var v float64 // out
	v = float64(m.native.bottom)
	return v
}
