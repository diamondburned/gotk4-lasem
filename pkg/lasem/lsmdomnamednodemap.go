// Code generated by girgen. DO NOT EDIT.

package lasem

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <lsm.h>
// #include <lsmdom.h>
// #include <lsmdomdocument.h>
// #include <lsmdomdocumentfragment.h>
// #include <lsmdomnamednodemap.h>
// extern LsmDomNode* _gotk4_lasem0_DomNamedNodeMapClass_get_item(LsmDomNamedNodeMap*, unsigned int);
// extern unsigned int _gotk4_lasem0_DomNamedNodeMapClass_get_length(LsmDomNamedNodeMap*);
import "C"

// glib.Type values for lsmdomnamednodemap.go.
var GTypeDOMNamedNodeMap = externglib.Type(C.lsm_dom_named_node_map_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeDOMNamedNodeMap, F: marshalDOMNamedNodeMap},
	})
}

// DOMNamedNodeMapOverrider contains methods that are overridable.
type DOMNamedNodeMapOverrider interface {
	// The function takes the following parameters:
	//
	//    - index: item index.
	//
	// The function returns the following values:
	//
	//    - domNode: node corresponding to index, NULL on error.
	//
	Item(index uint) DOMNoder
	// The function returns the following values:
	//
	Length() uint
}

type DOMNamedNodeMap struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*DOMNamedNodeMap)(nil)
)

// DOMNamedNodeMapper describes types inherited from class DOMNamedNodeMap.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type DOMNamedNodeMapper interface {
	externglib.Objector
	baseDOMNamedNodeMap() *DOMNamedNodeMap
}

var _ DOMNamedNodeMapper = (*DOMNamedNodeMap)(nil)

func classInitDOMNamedNodeMapper(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.LsmDomNamedNodeMapClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.LsmDomNamedNodeMapClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ Item(index uint) DOMNoder }); ok {
		pclass.get_item = (*[0]byte)(C._gotk4_lasem0_DomNamedNodeMapClass_get_item)
	}

	if _, ok := goval.(interface{ Length() uint }); ok {
		pclass.get_length = (*[0]byte)(C._gotk4_lasem0_DomNamedNodeMapClass_get_length)
	}
}

//export _gotk4_lasem0_DomNamedNodeMapClass_get_item
func _gotk4_lasem0_DomNamedNodeMapClass_get_item(arg0 *C.LsmDomNamedNodeMap, arg1 C.uint) (cret *C.LsmDomNode) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Item(index uint) DOMNoder })

	var _index uint // out

	_index = uint(arg1)

	domNode := iface.Item(_index)

	cret = (*C.LsmDomNode)(unsafe.Pointer(externglib.InternObject(domNode).Native()))

	return cret
}

//export _gotk4_lasem0_DomNamedNodeMapClass_get_length
func _gotk4_lasem0_DomNamedNodeMapClass_get_length(arg0 *C.LsmDomNamedNodeMap) (cret C.uint) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Length() uint })

	guint := iface.Length()

	cret = C.uint(guint)

	return cret
}

func wrapDOMNamedNodeMap(obj *externglib.Object) *DOMNamedNodeMap {
	return &DOMNamedNodeMap{
		Object: obj,
	}
}

func marshalDOMNamedNodeMap(p uintptr) (interface{}, error) {
	return wrapDOMNamedNodeMap(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (_map *DOMNamedNodeMap) baseDOMNamedNodeMap() *DOMNamedNodeMap {
	return _map
}

// BaseDOMNamedNodeMap returns the underlying base object.
func BaseDOMNamedNodeMap(obj DOMNamedNodeMapper) *DOMNamedNodeMap {
	return obj.baseDOMNamedNodeMap()
}

// The function takes the following parameters:
//
//    - index: item index.
//
// The function returns the following values:
//
//    - domNode: node corresponding to index, NULL on error.
//
func (_map *DOMNamedNodeMap) Item(index uint) DOMNoder {
	var _arg0 *C.LsmDomNamedNodeMap // out
	var _arg1 C.uint                // out
	var _cret *C.LsmDomNode         // in

	_arg0 = (*C.LsmDomNamedNodeMap)(unsafe.Pointer(externglib.InternObject(_map).Native()))
	_arg1 = C.uint(index)

	_cret = C.lsm_dom_named_node_map_get_item(_arg0, _arg1)
	runtime.KeepAlive(_map)
	runtime.KeepAlive(index)

	var _domNode DOMNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type lasem.DOMNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(DOMNoder)
			return ok
		})
		rv, ok := casted.(DOMNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching lasem.DOMNoder")
		}
		_domNode = rv
	}

	return _domNode
}

// The function returns the following values:
//
func (_map *DOMNamedNodeMap) Length() uint {
	var _arg0 *C.LsmDomNamedNodeMap // out
	var _cret C.uint                // in

	_arg0 = (*C.LsmDomNamedNodeMap)(unsafe.Pointer(externglib.InternObject(_map).Native()))

	_cret = C.lsm_dom_named_node_map_get_length(_arg0)
	runtime.KeepAlive(_map)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//    - name of the requested item.
//
// The function returns the following values:
//
//    - domNode: corresponding node, NULL if not found.
//
func (_map *DOMNamedNodeMap) NamedItem(name string) DOMNoder {
	var _arg0 *C.LsmDomNamedNodeMap // out
	var _arg1 *C.char               // out
	var _cret *C.LsmDomNode         // in

	_arg0 = (*C.LsmDomNamedNodeMap)(unsafe.Pointer(externglib.InternObject(_map).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.lsm_dom_named_node_map_get_named_item(_arg0, _arg1)
	runtime.KeepAlive(_map)
	runtime.KeepAlive(name)

	var _domNode DOMNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type lasem.DOMNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(DOMNoder)
			return ok
		})
		rv, ok := casted.(DOMNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching lasem.DOMNoder")
		}
		_domNode = rv
	}

	return _domNode
}

// The function takes the following parameters:
//
//    - name of the item to remove.
//
// The function returns the following values:
//
//    - domNode: removed node, NULL on error.
//
func (_map *DOMNamedNodeMap) RemoveNamedItem(name string) DOMNoder {
	var _arg0 *C.LsmDomNamedNodeMap // out
	var _arg1 *C.char               // out
	var _cret *C.LsmDomNode         // in

	_arg0 = (*C.LsmDomNamedNodeMap)(unsafe.Pointer(externglib.InternObject(_map).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.lsm_dom_named_node_map_remove_named_item(_arg0, _arg1)
	runtime.KeepAlive(_map)
	runtime.KeepAlive(name)

	var _domNode DOMNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type lasem.DOMNoder is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(DOMNoder)
			return ok
		})
		rv, ok := casted.(DOMNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching lasem.DOMNoder")
		}
		_domNode = rv
	}

	return _domNode
}

// The function takes the following parameters:
//
//    - node: DomNode.
//
// The function returns the following values:
//
//    - domNode: same as node, NULL on error.
//
func (_map *DOMNamedNodeMap) SetNamedItem(node DOMNoder) DOMNoder {
	var _arg0 *C.LsmDomNamedNodeMap // out
	var _arg1 *C.LsmDomNode         // out
	var _cret *C.LsmDomNode         // in

	_arg0 = (*C.LsmDomNamedNodeMap)(unsafe.Pointer(externglib.InternObject(_map).Native()))
	_arg1 = (*C.LsmDomNode)(unsafe.Pointer(externglib.InternObject(node).Native()))

	_cret = C.lsm_dom_named_node_map_set_named_item(_arg0, _arg1)
	runtime.KeepAlive(_map)
	runtime.KeepAlive(node)

	var _domNode DOMNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type lasem.DOMNoder is nil")
		}

		object := externglib.Take(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(DOMNoder)
			return ok
		})
		rv, ok := casted.(DOMNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching lasem.DOMNoder")
		}
		_domNode = rv
	}

	return _domNode
}
