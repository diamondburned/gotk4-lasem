// Code generated by girgen. DO NOT EDIT.

package lasem

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <lsm.h>
// #include <lsmdom.h>
// #include <lsmdomdocument.h>
// #include <lsmdomdocumentfragment.h>
// #include <lsmdomnamednodemap.h>
// #include <lsmmathmlactionelement.h>
// #include <lsmmathmlaligngroupelement.h>
// #include <lsmmathmlalignmarkelement.h>
// #include <lsmmathmlattributes.h>
// #include <lsmmathmldocument.h>
// #include <lsmmathmlelement.h>
// #include <lsmmathmlencloseelement.h>
// #include <lsmmathmlenums.h>
// #include <lsmmathmlerrorelement.h>
// #include <lsmmathmlfencedelement.h>
// #include <lsmmathmlfractionelement.h>
// #include <lsmmathmlglyphtableams.h>
// #include <lsmmathmlitexelement.h>
// #include <lsmmathmllayoututils.h>
// #include <lsmmathmlmathelement.h>
// #include <lsmmathmloperatordictionary.h>
// #include <lsmmathmloperatorelement.h>
// #include <lsmmathmlpaddedelement.h>
// #include <lsmmathmlphantomelement.h>
// #include <lsmmathmlpresentationcontainer.h>
// #include <lsmmathmlpresentationtoken.h>
// #include <lsmmathmlradicalelement.h>
// #include <lsmmathmlrowelement.h>
// #include <lsmmathmlscriptelement.h>
// #include <lsmmathmlsemanticselement.h>
// #include <lsmmathmlspaceelement.h>
// #include <lsmmathmlstringelement.h>
// #include <lsmmathmlstyle.h>
// #include <lsmmathmlstyleelement.h>
// #include <lsmmathmltablecellelement.h>
// #include <lsmmathmltableelement.h>
// #include <lsmmathmltablerowelement.h>
// #include <lsmmathmltraits.h>
// #include <lsmmathmlunderoverelement.h>
// #include <lsmmathmlutils.h>
// #include <lsmmathmlview.h>
// #include <lsmsvgaelement.h>
// #include <lsmsvgattributes.h>
// #include <lsmsvgcircleelement.h>
// #include <lsmsvgclippathelement.h>
// #include <lsmsvgcolors.h>
// #include <lsmsvgdefselement.h>
// #include <lsmsvgdocument.h>
// #include <lsmsvgelement.h>
// #include <lsmsvgellipseelement.h>
// #include <lsmsvgenums.h>
// #include <lsmsvgfilterblend.h>
// #include <lsmsvgfiltercolormatrix.h>
// #include <lsmsvgfiltercomposite.h>
// #include <lsmsvgfilterconvolvematrix.h>
// #include <lsmsvgfilterdisplacementmap.h>
// #include <lsmsvgfilterelement.h>
// #include <lsmsvgfilterflood.h>
// #include <lsmsvgfiltergaussianblur.h>
// #include <lsmsvgfilterimage.h>
// #include <lsmsvgfiltermerge.h>
// #include <lsmsvgfiltermergenode.h>
// #include <lsmsvgfiltermorphology.h>
// #include <lsmsvgfilteroffset.h>
// #include <lsmsvgfilterprimitive.h>
// #include <lsmsvgfilterspecularlighting.h>
// #include <lsmsvgfiltersurface.h>
// #include <lsmsvgfiltertile.h>
// #include <lsmsvgfilterturbulence.h>
// #include <lsmsvggelement.h>
// #include <lsmsvggradientelement.h>
// #include <lsmsvgimageelement.h>
// #include <lsmsvglength.h>
// #include <lsmsvglineargradientelement.h>
// #include <lsmsvglineelement.h>
// #include <lsmsvgmarkerelement.h>
// #include <lsmsvgmaskelement.h>
// #include <lsmsvgmatrix.h>
// #include <lsmsvgpathelement.h>
// #include <lsmsvgpatternelement.h>
// #include <lsmsvgpolygonelement.h>
// #include <lsmsvgpolylineelement.h>
// #include <lsmsvgradialgradientelement.h>
// #include <lsmsvgrectelement.h>
// #include <lsmsvgstopelement.h>
// #include <lsmsvgstyle.h>
// #include <lsmsvgsvgelement.h>
// #include <lsmsvgswitchelement.h>
// #include <lsmsvgsymbolelement.h>
// #include <lsmsvgtextelement.h>
// #include <lsmsvgtraits.h>
// #include <lsmsvgtransformable.h>
// #include <lsmsvgtspanelement.h>
// #include <lsmsvguseelement.h>
// #include <lsmsvgview.h>
// extern LsmMathmlBbox* _gotk4_lasem0_MathmlElementClass_measure(LsmMathmlElement*, LsmMathmlView*, LsmMathmlBbox*);
// extern gboolean _gotk4_lasem0_MathmlElementClass_is_inferred_row(LsmMathmlElement*);
// extern gboolean _gotk4_lasem0_MathmlElementClass_update_children(LsmMathmlElement*, LsmMathmlStyle*);
// extern void _gotk4_lasem0_MathmlElementClass_layout(LsmMathmlElement*, LsmMathmlView*, double, double, LsmMathmlBbox*);
// extern void _gotk4_lasem0_MathmlElementClass_render(LsmMathmlElement*, LsmMathmlView*);
// extern void _gotk4_lasem0_MathmlElementClass_update(LsmMathmlElement*, LsmMathmlStyle*);
import "C"

// glib.Type values for lsmmathmlelement.go.
var GTypeMathMLElement = externglib.Type(C.lsm_mathml_element_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeMathMLElement, F: marshalMathMLElement},
	})
}

// MathMLElementOverrider contains methods that are overridable.
type MathMLElementOverrider interface {
	// The function returns the following values:
	//
	IsInferredRow() bool
	// The function takes the following parameters:
	//
	//    - view
	//    - x
	//    - y
	//    - bbox
	//
	Layout(view *MathMLView, x, y float64, bbox *MathMLBbox)
	// The function takes the following parameters:
	//
	//    - view
	//    - bbox
	//
	// The function returns the following values:
	//
	Measure(view *MathMLView, bbox *MathMLBbox) *MathMLBbox
	// The function takes the following parameters:
	//
	Render(view *MathMLView)
	// The function takes the following parameters:
	//
	Update(style *MathMLStyle)
	// The function takes the following parameters:
	//
	// The function returns the following values:
	//
	UpdateChildren(style *MathMLStyle) bool
}

type MathMLElement struct {
	_ [0]func() // equal guard
	DOMElement
}

var (
	_ DOMElementer = (*MathMLElement)(nil)
)

// MathMLElementer describes types inherited from class MathMLElement.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MathMLElementer interface {
	externglib.Objector
	baseMathMLElement() *MathMLElement
}

var _ MathMLElementer = (*MathMLElement)(nil)

func classInitMathMLElementer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.LsmMathmlElementClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.LsmMathmlElementClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface{ IsInferredRow() bool }); ok {
		pclass.is_inferred_row = (*[0]byte)(C._gotk4_lasem0_MathmlElementClass_is_inferred_row)
	}

	if _, ok := goval.(interface {
		Layout(view *MathMLView, x, y float64, bbox *MathMLBbox)
	}); ok {
		pclass.layout = (*[0]byte)(C._gotk4_lasem0_MathmlElementClass_layout)
	}

	if _, ok := goval.(interface {
		Measure(view *MathMLView, bbox *MathMLBbox) *MathMLBbox
	}); ok {
		pclass.measure = (*[0]byte)(C._gotk4_lasem0_MathmlElementClass_measure)
	}

	if _, ok := goval.(interface{ Render(view *MathMLView) }); ok {
		pclass.render = (*[0]byte)(C._gotk4_lasem0_MathmlElementClass_render)
	}

	if _, ok := goval.(interface{ Update(style *MathMLStyle) }); ok {
		pclass.update = (*[0]byte)(C._gotk4_lasem0_MathmlElementClass_update)
	}

	if _, ok := goval.(interface{ UpdateChildren(style *MathMLStyle) bool }); ok {
		pclass.update_children = (*[0]byte)(C._gotk4_lasem0_MathmlElementClass_update_children)
	}
}

//export _gotk4_lasem0_MathmlElementClass_is_inferred_row
func _gotk4_lasem0_MathmlElementClass_is_inferred_row(arg0 *C.LsmMathmlElement) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ IsInferredRow() bool })

	ok := iface.IsInferredRow()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_lasem0_MathmlElementClass_layout
func _gotk4_lasem0_MathmlElementClass_layout(arg0 *C.LsmMathmlElement, arg1 *C.LsmMathmlView, arg2 C.double, arg3 C.double, arg4 *C.LsmMathmlBbox) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Layout(view *MathMLView, x, y float64, bbox *MathMLBbox)
	})

	var _view *MathMLView // out
	var _x float64        // out
	var _y float64        // out
	var _bbox *MathMLBbox // out

	_view = wrapMathMLView(externglib.Take(unsafe.Pointer(arg1)))
	_x = float64(arg2)
	_y = float64(arg3)
	_bbox = (*MathMLBbox)(gextras.NewStructNative(unsafe.Pointer(arg4)))

	iface.Layout(_view, _x, _y, _bbox)
}

//export _gotk4_lasem0_MathmlElementClass_measure
func _gotk4_lasem0_MathmlElementClass_measure(arg0 *C.LsmMathmlElement, arg1 *C.LsmMathmlView, arg2 *C.LsmMathmlBbox) (cret *C.LsmMathmlBbox) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Measure(view *MathMLView, bbox *MathMLBbox) *MathMLBbox
	})

	var _view *MathMLView // out
	var _bbox *MathMLBbox // out

	_view = wrapMathMLView(externglib.Take(unsafe.Pointer(arg1)))
	_bbox = (*MathMLBbox)(gextras.NewStructNative(unsafe.Pointer(arg2)))

	mathmlBbox := iface.Measure(_view, _bbox)

	cret = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(mathmlBbox)))

	return cret
}

//export _gotk4_lasem0_MathmlElementClass_render
func _gotk4_lasem0_MathmlElementClass_render(arg0 *C.LsmMathmlElement, arg1 *C.LsmMathmlView) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Render(view *MathMLView) })

	var _view *MathMLView // out

	_view = wrapMathMLView(externglib.Take(unsafe.Pointer(arg1)))

	iface.Render(_view)
}

//export _gotk4_lasem0_MathmlElementClass_update
func _gotk4_lasem0_MathmlElementClass_update(arg0 *C.LsmMathmlElement, arg1 *C.LsmMathmlStyle) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Update(style *MathMLStyle) })

	var _style *MathMLStyle // out

	_style = (*MathMLStyle)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	iface.Update(_style)
}

//export _gotk4_lasem0_MathmlElementClass_update_children
func _gotk4_lasem0_MathmlElementClass_update_children(arg0 *C.LsmMathmlElement, arg1 *C.LsmMathmlStyle) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ UpdateChildren(style *MathMLStyle) bool })

	var _style *MathMLStyle // out

	_style = (*MathMLStyle)(gextras.NewStructNative(unsafe.Pointer(arg1)))

	ok := iface.UpdateChildren(_style)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapMathMLElement(obj *externglib.Object) *MathMLElement {
	return &MathMLElement{
		DOMElement: DOMElement{
			DOMNode: DOMNode{
				Object: obj,
			},
		},
	}
}

func marshalMathMLElement(p uintptr) (interface{}, error) {
	return wrapMathMLElement(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *MathMLElement) baseMathMLElement() *MathMLElement {
	return self
}

// BaseMathMLElement returns the underlying base object.
func BaseMathMLElement(obj MathMLElementer) *MathMLElement {
	return obj.baseMathMLElement()
}

// The function returns the following values:
//
func (self *MathMLElement) Bbox() *MathMLBbox {
	var _arg0 *C.LsmMathmlElement // out
	var _cret *C.LsmMathmlBbox    // in

	_arg0 = (*C.LsmMathmlElement)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.lsm_mathml_element_get_bbox(_arg0)
	runtime.KeepAlive(self)

	var _mathmlBbox *MathMLBbox // out

	_mathmlBbox = (*MathMLBbox)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _mathmlBbox
}

// The function returns the following values:
//
func (self *MathMLElement) IsInferredRow() bool {
	var _arg0 *C.LsmMathmlElement // out
	var _cret C.gboolean          // in

	_arg0 = (*C.LsmMathmlElement)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.lsm_mathml_element_is_inferred_row(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//    - view
//    - x
//    - y
//    - bbox
//
func (element *MathMLElement) Layout(view *MathMLView, x, y float64, bbox *MathMLBbox) {
	var _arg0 *C.LsmMathmlElement // out
	var _arg1 *C.LsmMathmlView    // out
	var _arg2 C.double            // out
	var _arg3 C.double            // out
	var _arg4 *C.LsmMathmlBbox    // out

	_arg0 = (*C.LsmMathmlElement)(unsafe.Pointer(externglib.InternObject(element).Native()))
	_arg1 = (*C.LsmMathmlView)(unsafe.Pointer(externglib.InternObject(view).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)
	_arg4 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(bbox)))

	C.lsm_mathml_element_layout(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(element)
	runtime.KeepAlive(view)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(bbox)
}

// The function takes the following parameters:
//
//    - view
//    - stretchBbox
//
// The function returns the following values:
//
func (element *MathMLElement) Measure(view *MathMLView, stretchBbox *MathMLBbox) *MathMLBbox {
	var _arg0 *C.LsmMathmlElement // out
	var _arg1 *C.LsmMathmlView    // out
	var _arg2 *C.LsmMathmlBbox    // out
	var _cret *C.LsmMathmlBbox    // in

	_arg0 = (*C.LsmMathmlElement)(unsafe.Pointer(externglib.InternObject(element).Native()))
	_arg1 = (*C.LsmMathmlView)(unsafe.Pointer(externglib.InternObject(view).Native()))
	_arg2 = (*C.LsmMathmlBbox)(gextras.StructNative(unsafe.Pointer(stretchBbox)))

	_cret = C.lsm_mathml_element_measure(_arg0, _arg1, _arg2)
	runtime.KeepAlive(element)
	runtime.KeepAlive(view)
	runtime.KeepAlive(stretchBbox)

	var _mathmlBbox *MathMLBbox // out

	_mathmlBbox = (*MathMLBbox)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _mathmlBbox
}

// The function takes the following parameters:
//
func (element *MathMLElement) Render(view *MathMLView) {
	var _arg0 *C.LsmMathmlElement // out
	var _arg1 *C.LsmMathmlView    // out

	_arg0 = (*C.LsmMathmlElement)(unsafe.Pointer(externglib.InternObject(element).Native()))
	_arg1 = (*C.LsmMathmlView)(unsafe.Pointer(externglib.InternObject(view).Native()))

	C.lsm_mathml_element_render(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(view)
}

// Update the actual property of an element and it's children. This function
// parses the element attributes and also make elements inherit style from their
// parents.
//
// The function takes the following parameters:
//
// The function returns the following values:
//
//    - ok: TRUE if the size of the element has changed and needs to be
//      recalculated.
//
func (element *MathMLElement) Update(style *MathMLStyle) bool {
	var _arg0 *C.LsmMathmlElement // out
	var _arg1 *C.LsmMathmlStyle   // out
	var _cret C.gboolean          // in

	_arg0 = (*C.LsmMathmlElement)(unsafe.Pointer(externglib.InternObject(element).Native()))
	_arg1 = (*C.LsmMathmlStyle)(gextras.StructNative(unsafe.Pointer(style)))

	_cret = C.lsm_mathml_element_update(_arg0, _arg1)
	runtime.KeepAlive(element)
	runtime.KeepAlive(style)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MathMLElementStyle: instance of this type is always passed by reference.
type MathMLElementStyle struct {
	*mathMLElementStyle
}

// mathMLElementStyle is the struct that's finalized.
type mathMLElementStyle struct {
	native *C.LsmMathmlElementStyle
}

func (m *MathMLElementStyle) MathFamily() string {
	var v string // out
	v = C.GoString((*C.gchar)(unsafe.Pointer(m.native.math_family)))
	return v
}

func (m *MathMLElementStyle) MathVariant() MathMLVariant {
	var v MathMLVariant // out
	v = MathMLVariant(m.native.math_variant)
	return v
}

func (m *MathMLElementStyle) MathSize() float64 {
	var v float64 // out
	v = float64(m.native.math_size)
	return v
}

func (m *MathMLElementStyle) MathColor() *MathMLColor {
	var v *MathMLColor // out
	v = (*MathMLColor)(gextras.NewStructNative(unsafe.Pointer((&m.native.math_color))))
	return v
}

func (m *MathMLElementStyle) MathBackground() *MathMLColor {
	var v *MathMLColor // out
	v = (*MathMLColor)(gextras.NewStructNative(unsafe.Pointer((&m.native.math_background))))
	return v
}
